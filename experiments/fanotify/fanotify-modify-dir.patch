diff --git a/fs/namei.c b/fs/namei.c
index 9c590e0..f2c2295 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -2928,8 +2928,11 @@ static int atomic_open(struct nameidata *nd, struct dentry *dentry,
 			dput(dentry);
 			dentry = file->f_path.dentry;
 		}
-		if (*opened & FILE_CREATED)
+		if (*opened & FILE_CREATED) {
+			struct path parent_path = {file->f_path.mnt, dentry->d_parent};
 			fsnotify_create(dir, dentry);
+			fsnotify_modify_dir(&parent_path);
+		}
 		if (!dentry->d_inode) {
 			WARN_ON(*opened & FILE_CREATED);
 			if (create_error) {
@@ -2951,8 +2954,10 @@ static int atomic_open(struct nameidata *nd, struct dentry *dentry,
 	 */
 	acc_mode = op->acc_mode;
 	if (*opened & FILE_CREATED) {
+		struct path parent_path = {file->f_path.mnt, dentry->d_parent};
 		WARN_ON(!(open_flag & O_CREAT));
 		fsnotify_create(dir, dentry);
+		fsnotify_modify_dir(&parent_path);
 		acc_mode = 0;
 	}
 	error = may_open(&file->f_path, acc_mode, open_flag);
@@ -3066,6 +3071,7 @@ static int lookup_open(struct nameidata *nd, struct path *path,
 				   nd->flags & LOOKUP_EXCL);
 		if (error)
 			goto out_dput;
+		fsnotify_modify_dir(&nd->path);
 	}
 out_no_open:
 	path->dentry = dentry;
@@ -3637,6 +3643,7 @@ retry:
 			error = vfs_mknod(path.dentry->d_inode,dentry,mode,0);
 			break;
 	}
+	fsnotify_modify_dir(&path);
 out:
 	done_path_create(&path, dentry);
 	if (retry_estale(error, lookup_flags)) {
@@ -3694,6 +3701,8 @@ retry:
 	error = security_path_mkdir(&path, dentry, mode);
 	if (!error)
 		error = vfs_mkdir(path.dentry->d_inode, dentry, mode);
+	if (!error)
+		fsnotify_modify_dir(&path);
 	done_path_create(&path, dentry);
 	if (retry_estale(error, lookup_flags)) {
 		lookup_flags |= LOOKUP_REVAL;
@@ -3815,6 +3824,8 @@ retry:
 	if (error)
 		goto exit3;
 	error = vfs_rmdir(path.dentry->d_inode, dentry);
+	if (!error)
+		fsnotify_modify_dir(&path);
 exit3:
 	dput(dentry);
 exit2:
@@ -3939,6 +3950,8 @@ retry_deleg:
 		if (error)
 			goto exit2;
 		error = vfs_unlink(path.dentry->d_inode, dentry, &delegated_inode);
+		if (!error)
+			fsnotify_modify_dir(&path);
 exit2:
 		dput(dentry);
 	}
@@ -4030,6 +4043,8 @@ retry:
 	error = security_path_symlink(&path, dentry, from->name);
 	if (!error)
 		error = vfs_symlink(path.dentry->d_inode, dentry, from->name);
+	if (!error)
+		fsnotify_modify_dir(&path);
 	done_path_create(&path, dentry);
 	if (retry_estale(error, lookup_flags)) {
 		lookup_flags |= LOOKUP_REVAL;
@@ -4172,6 +4187,8 @@ retry:
 	if (error)
 		goto out_dput;
 	error = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);
+	if (!error)
+		fsnotify_modify_dir(&new_path);
 out_dput:
 	done_path_create(&new_path, new_dentry);
 	if (delegated_inode) {
@@ -4494,6 +4511,10 @@ retry_deleg:
 	error = vfs_rename(old_path.dentry->d_inode, old_dentry,
 			   new_path.dentry->d_inode, new_dentry,
 			   &delegated_inode, flags);
+	if (error == 0) {
+		fsnotify_modify_dir(&old_path);
+		fsnotify_modify_dir(&new_path);
+	}
 exit5:
 	dput(new_dentry);
 exit4:
diff --git a/fs/notify/fanotify/fanotify.c b/fs/notify/fanotify/fanotify.c
index d2f97ec..c424f67 100644
--- a/fs/notify/fanotify/fanotify.c
+++ b/fs/notify/fanotify/fanotify.c
@@ -197,6 +197,7 @@ static int fanotify_handle_event(struct fsnotify_group *group,
 
 	BUILD_BUG_ON(FAN_ACCESS != FS_ACCESS);
 	BUILD_BUG_ON(FAN_MODIFY != FS_MODIFY);
+	BUILD_BUG_ON(FAN_MODIFY_DIR != FS_MODIFY_DIR);
 	BUILD_BUG_ON(FAN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);
 	BUILD_BUG_ON(FAN_CLOSE_WRITE != FS_CLOSE_WRITE);
 	BUILD_BUG_ON(FAN_OPEN != FS_OPEN);
diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h
index 7ee1774..57787b7 100644
--- a/include/linux/fsnotify.h
+++ b/include/linux/fsnotify.h
@@ -225,6 +225,22 @@ static inline void fsnotify_modify(struct file *file)
 }
 
 /*
+ * fsnotify_modifydir - directory contents were changed (as a result of rename, creat, unlink, etc.)
+ */
+static inline void fsnotify_modify_dir(struct path *path)
+{
+	struct inode *inode = path->dentry->d_inode;
+	__u32 mask = FS_MODIFY_DIR;
+
+	if (S_ISDIR(inode->i_mode))
+		mask |= FS_ISDIR;
+	else
+		return;
+
+	fsnotify(inode, mask, path, FSNOTIFY_EVENT_PATH, NULL, 0);
+}
+
+/*
  * fsnotify_open - file was opened
  */
 static inline void fsnotify_open(struct file *file)
diff --git a/include/linux/fsnotify_backend.h b/include/linux/fsnotify_backend.h
index 533c440..d32ccff 100644
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@ -42,6 +42,7 @@
 
 #define FS_OPEN_PERM		0x00010000	/* open event in an permission hook */
 #define FS_ACCESS_PERM		0x00020000	/* access event in a permissions hook */
+#define FS_MODIFY_DIR		0x00040000	/* directory changed (create/unlink/...) */
 
 #define FS_EXCL_UNLINK		0x04000000	/* do not send events if object is unlinked */
 #define FS_ISDIR		0x40000000	/* event occurred against dir */
diff --git a/include/uapi/linux/fanotify.h b/include/uapi/linux/fanotify.h
index 030508d..737b561 100644
--- a/include/uapi/linux/fanotify.h
+++ b/include/uapi/linux/fanotify.h
@@ -15,6 +15,8 @@
 #define FAN_OPEN_PERM		0x00010000	/* File open in perm check */
 #define FAN_ACCESS_PERM		0x00020000	/* File accessed in perm check */
 
+#define FAN_MODIFY_DIR		0x00040000	/* directory changed (rename/unlink/...) */
+
 #define FAN_ONDIR		0x40000000	/* event occurred against dir */
 
 #define FAN_EVENT_ON_CHILD	0x08000000	/* interested in child events */
@@ -67,7 +69,8 @@
 #define FAN_ALL_EVENTS (FAN_ACCESS |\
 			FAN_MODIFY |\
 			FAN_CLOSE |\
-			FAN_OPEN)
+			FAN_OPEN |\
+			FAN_MODIFY_DIR)
 
 /*
  * All events which require a permission response from userspace
